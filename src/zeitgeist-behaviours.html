<script src="/bower_components/underscore/underscore-min.js"></script>
<script>
	window.Zeitgeist = window.Zeitgeist || {
    fetchArticles: (limit) => {
      return fetch('http://localhost:8080/api/articles', {mode: 'cors'})
      .then((resp) => { return resp.json(); })
    },
  	generateGraph: (N, E) => {
  		var g = {
  			nodes: [],
  			edges: []
  		}
  		g.nodes = _.map(_.range(N), (i) => {
  			return {
  				id: i,
                  label: 'Node ' + i,
                  x: Math.random() * 100,
                  y: Math.random() * 100,
                  size: Math.random() * 10,
                  color: '#666'
  			}
  		});
  		g.edges = _.map(_.range(E), (i) => {
  			return {
  				id: i,
                  source: (Math.random() * N | 0),
                  target: (Math.random() * N | 0),
                  size: Math.random(),
                  color: '#ccc'
  			}
  		});
  		return g;
  	},
  	applyNodeStyle: function(node) {
  		node._label = node.label;
  		if(_.keys(node).indexOf('properties') == -1) {
  			return node;
  		}
  		switch(node._label) {
  			case 'author':
  				if(_.keys(node.properties).indexOf('standard_name') == -1) {
  					return node;
  				}
  				node.label = node.properties.standard_name[0].value;
  				node.color = "#3F51B5";
  				break;
  			case 'article':
  				node.label = node.properties.title[0].value;
  				node.color = '#009688';
  				break;
  		}
  		return node;
  	},
    processNodeList: (nodes) => {
      var minSize = 1;
      var maxSize = 5;
      return _.map(nodes, (node) => {
        node.x = Math.random() * 100;
        node.y = Math.random() * 100;
        node.color = "#000";
        node.size = Math.random() * (maxSize - minSize) + minSize;
        return node;
      })
    },
  	processGraphson: function(graph) {
      console.log(graph);

  		var graphson = _.map((nodes.slice(0, nodes.length - 2)), function(node) {
  			return JSON.parse(node);
  		});
  		nodes = [];
  		nodes = _.map(graphson.slice(0, 10000), (node) => {
  			var x =  _.omit(node, (value, key, object) => {
  				return (key == 'inE' || key == 'outE');
  			});
  			x.x = Math.random() * 100;
  			x.y = Math.random() * 100;
  			x.size = 0;
  			// if(_.keys(node).indexOf('inE') != -1) {
  			// 	x.size += _.flatten(_.map(node.inE, (edge_type) => {
  			// 		return x;
  			// 	}))
  			// }
  			x =  Zeitgeist.applyNodeStyle(x);
  			return x;
  		});
  		var node_indices = _.map(nodes, (node) => { return node.id });
  		edges = _.without(_.uniq(_.flatten(_.map(graphson.slice(0, 10000), (node) => {
  			var outE = [];
  			var inE = [];
  			if(_.keys(node).indexOf('inE') != -1) {
  				inE = _.map(node.inE, (edgeset) => {
  					return _.map(edgeset, (edge) => {
  						return {source: edge.outV, properties: edge.properties, id: edge.id, target: node.id, color: "#9E9E9E"}
  					});
  				});
  			}
  			if(_.keys(node).indexOf('outE') != -1) {
  				outE = _.map(node.outE, (edgeset) => {
  					return _.map(edgeset, (edge) => {
  						var x =  {target: edge.inV, properties: edge.properties, id: edge.id, source: node.id, color: "#9E9E9E"};
  						return x;
  					});
  				});
  			}
  			return outE.concat(inE);
  		})), (edge) => {
  			return (edge.target, edge.source)
  		}), (edge) => {
  			return (node_indices.indexOf(edge.target) == -1 || node_indices.indexOf(edge.source) == -1)
  		});;
  		return {nodes: nodes, edges: edges};
  	},
  	applyGraphStyles: function(sigmaInstance) {

  	},
  	applyGraphInteractions: function(sigmaInstance) {
  		sigmaInstance.bind('doubleClickNode', function(e) {
  			console.log(e);
  		});
  		sigmaInstance.bind('hovers', function(e) {
  			var adjacentNodes = [];

  	        if (!e.data.enter.nodes.length) return;

  	        // Get deduped, flattened list of all neighbours of all nodes in hover
  	        adjacentNodes = _.uniq(_.flatten(_.map(e.data.enter.nodes, (node) => {
  	        	return this.graph.adjacentNodes(node.id)
  	        })));

  	            // Render halo:
  	        this.renderers[0].halo({
  	        nodes: adjacentNodes
  	        });
  		}.bind(sigmaInstance))

  		sigma.plugins.tooltips(sigmaInstance, sigmaInstance.renderers[0], {
  			node: [{
  	            show: 'clickNode',
  	            renderer: function(node) {
  	            	console.log(node);
  	            }
              }]
  		});
  	},
  	applyForceLink: function(sigmaInstance) {
  		var fa = sigma.layouts.configForceLink(sigmaInstance, {
  			worker: true,
  			autoStop: true,
  			background: false,
  			scaleRatio: 10,
  			gravity: 5,
  			easing: 'cubicInOut'
  		});
  		// Bind the events:
  		fa.bind('start stop', function(e) {
  			console.log(e.type);
  		});
  		// Start the ForceLink algorithm:
  		sigma.layouts.startForceLink();
  		console.log("ForceLink started");
  		return fa;
  	},
  	findNeighbourhoodOfAuthor: function(graph,author_st_name) {
  		return graph;
  	}
  }
</script>
